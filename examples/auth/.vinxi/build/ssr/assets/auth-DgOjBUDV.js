import{setEnvDefaults as H,createActionURL as R,Auth as w,raw as x,skipCSRFCheck as L,isAuthAction as I}from"@auth/core";import"@auth/core/errors";import{H3Event as _,sendRedirect as k}from"h3";import{AsyncLocalStorage as q}from"node:async_hooks";import{isDev as N}from"solid-js/web";import V from"@auth/core/providers/discord";import j from"@auth/core/providers/credentials";import{z as T}from"zod";function z(e={}){let t,n=!1;const r=s=>{if(t&&t!==s)throw new Error("Context conflict")};let o;if(e.asyncContext){const s=e.AsyncLocalStorage||globalThis.AsyncLocalStorage;s?o=new s:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const i=()=>{if(o&&t===void 0){const s=o.getStore();if(s!==void 0)return s}return t};return{use:()=>{const s=i();if(s===void 0)throw new Error("Context is not available");return s},tryUse:()=>i(),set:(s,a)=>{a||r(s),t=s,n=!0},unset:()=>{t=void 0,n=!1},call:(s,a)=>{r(s),t=s;try{return o?o.run(s,a):a()}finally{n||(t=void 0)}},async callAsync(s,a){t=s;const l=()=>{t=s},p=()=>t===s?l:void 0;A.add(p);try{const u=o?o.run(s,a):a();return n||(t=void 0),await u}finally{A.delete(p)}}}}function W(e={}){const t={};return{get(n,r={}){return t[n]||(t[n]=z({...e,...r})),t[n],t[n]}}}const m=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},b="__unctx__",F=m[b]||(m[b]=W()),M=(e,t={})=>F.get(e,t),P="__unctx_async_handlers__",A=m[P]||(m[P]=new Set);function le(e){const t=new URL("http://localhost:3000/api/auth");e&&!e.toString().startsWith("http")&&(e=`https://${e}`);const n=new URL(e??t),r=(n.pathname==="/"?t.pathname:n.pathname).replace(/\/$/,""),o=`${n.origin}${r}`;return{origin:n.origin,host:n.host,path:r,base:o,toString:()=>o}}const B=e=>{if(e.startsWith("VITE_"))return{BASE_URL:"/_build",CWD:"/Users/or/Desktop/mediakit2/examples/auth",DEV:!1,DEVTOOLS:!1,MANIFEST:globalThis.MANIFEST,MODE:"production",PROD:!0,ROUTERS:["public","ssr","client","server-fns"],ROUTER_HANDLER:"src/entry-server.tsx",ROUTER_NAME:"ssr",ROUTER_TYPE:"http",SERVER_BASE_URL:"",SSR:!0,START_APP:"./src/app.tsx",START_DEV_OVERLAY:!0,START_ISLANDS:!1,START_SSR:!0,VITE_AUTH_PATH:"/api/auth"}[e];if(typeof process<"u"&&typeof process.env<"u"&&!e.startsWith("VITE_"))return process.env[e]},K=(...e)=>{for(const t of e){const n=B(t);if(n)return n}};function d(e,t){H(e,t,!0),t.trustHost??=N,t.basePath??=O(t)}const O=e=>e?.basePath?e.basePath:K("VITE_AUTH_PATH")??"/api/auth";function Y(){return X()}const $=Symbol("$HTTPEvent");function G(e){return typeof e=="object"&&(e instanceof _||e?.[$]instanceof _||e?.__is_event__===!0)}function J(e){return function(...t){let n=t[0];if(G(n))t[0]=n instanceof _||n.__is_event__?n:n[$];else{if(!globalThis.app.config.server.experimental?.asyncContext)throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");if(n=Y(),!n)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");t.unshift(n)}return e(...t)}}const h=J(k);function Q(){return M("nitro-app",{asyncContext:!!globalThis.app.config.server.experimental?.asyncContext,AsyncLocalStorage:q})}function X(){return Q().use().event}const U="authorizationParams-";function fe(e){const t=async n=>{const r=typeof e=="object"?e:await e(n);d(process.env,r),r.basePath??=O(r);const{request:o}=n,i=new URL(o.url),s=i.pathname.slice(r.basePath.length+1).split("/")[0];return I(s)&&i.pathname.startsWith(r.basePath+"/")?w(o,r):new Response("Not Found",{status:404})};return{signIn:async n=>{const{request:r}=n,o=typeof e=="object"?e:await e(n);d(process.env,o);const i=await r.formData(),{providerId:s,...a}=Object.fromEntries(i);let l={},p={};for(const u in a)u.startsWith(U)?l[u.slice(U.length)]=a[u]:p[u]=a[u];await Z(s,p,l,o,n)},signOut:async n=>{const r=typeof e=="object"?e:await e(n);d(process.env,r);const o=Object.fromEntries(await n.request.formData());await ee(o,r,n)},GET:t,POST:t}}async function Z(e,t={},n,r,o){const{request:i}=o,{protocol:s}=new URL(i.url),a=new Headers(i.headers),{redirect:l=!0,redirectTo:p,...u}=t instanceof FormData?Object.fromEntries(t):t,f=p?.toString()??a.get("Referer")??"/",S=R("signin",s,a,process.env,r);if(!e){const c=`${S}?${new URLSearchParams({callbackUrl:f})}`;return l&&h(o.nativeEvent,c,302),c}let y=`${S}/${e}?${new URLSearchParams(n)}`,v;for(const c of r.providers){const{id:g}=typeof c=="function"?c():c;if(g===e){v=g;break}}if(!v){const c=`${S}?${new URLSearchParams({callbackUrl:f})}`;return l&&h(o.nativeEvent,c,302),c}v==="credentials"&&(y=y.replace("signin","callback")),a.set("Content-Type","application/x-www-form-urlencoded");const D=new URLSearchParams({...u,callbackUrl:f}),C=new Request(y,{method:"POST",headers:a,body:D}),E=await w(C,{...r,raw:x,skipCSRFCheck:L});for(const c of E?.cookies??[])o.response.headers.append("set-cookie",`${c.name}=${c.value}; Path=/; ${c.options?.httpOnly?"HttpOnly;":""} ${c.options?.secure?"Secure;":""} ${c.options?.sameSite?`SameSite=${c.options.sameSite};`:""}`);return l?h(o.nativeEvent,E.redirect,302):E.redirect}async function ee(e,t,n){const{request:r}=n,{protocol:o}=new URL(r.url),i=new Headers(r.headers);i.set("Content-Type","application/x-www-form-urlencoded");const s=R("signout",o,i,process.env,t),a=e?.redirectTo??i.get("Referer")??"/",l=new URLSearchParams({callbackUrl:a}),p=new Request(s,{method:"POST",headers:i,body:l}),u=await w(p,{...t,raw:x,skipCSRFCheck:L});for(const f of u?.cookies??[])n.response.headers.append("set-cookie",`${f.name}=${f.value}; Path=/; ${f.options?.httpOnly?"HttpOnly;":""} ${f.options?.secure?"Secure;":""} ${f.options?.sameSite?`SameSite=${f.options.sameSite};`:""}`);return e?.redirect??!0?h(n.nativeEvent,u.redirect,302):u}async function pe(e,t){const n="request"in e?e.request:e;d(process.env,t);const{protocol:r}=new URL(n.url),o=R("session",r,new Headers(n.headers),process.env,t),i=await w(new Request(o,{headers:n.headers}),t),{status:s=200}=i,a=await i.json();if(!a||!Object.keys(a).length)return null;if(s===200)return a;throw new Error(a.message)}const te=T.object({email:T.string().min(1).email(),password:T.string().min(4)}),de={providers:[V({clientId:process.env.DISCORD_ID,clientSecret:process.env.DISCORD_SECRET}),j({credentials:{email:{},password:{}},async authorize(e){const t=await te.safeParseAsync(e);if(!t.success)throw new Error("No Such User");return{name:t.data.email.split("@")[0],email:t.data.email}}})],debug:!1,basePath:"/api/auth"};export{fe as S,de as a,O as b,K as c,M as d,pe as g,le as p};
